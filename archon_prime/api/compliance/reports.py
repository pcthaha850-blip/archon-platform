"""
ARCHON PRIME - Compliance Report Generation

Generates compliance reports for regulatory, internal,
and audit purposes.
"""

import json
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from enum import Enum
from typing import List, Dict, Optional, Any
from uuid import uuid4


class ReportType(str, Enum):
    """Types of compliance reports."""

    # Regulatory
    SOC2_EVIDENCE = "soc2_evidence"
    GDPR_DATA_ACCESS = "gdpr_data_access"
    AUDIT_TRAIL = "audit_trail"

    # Internal
    EXECUTIVE_SUMMARY = "executive_summary"
    RISK_ASSESSMENT = "risk_assessment"
    INCIDENT_REPORT = "incident_report"

    # Trading
    TRADING_ACTIVITY = "trading_activity"
    SIGNAL_PERFORMANCE = "signal_performance"
    POSITION_REPORT = "position_report"

    # Operations
    SYSTEM_HEALTH = "system_health"
    ACCESS_REVIEW = "access_review"
    CHANGE_LOG = "change_log"


class ReportPeriod(str, Enum):
    """Standard report periods."""

    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    ANNUAL = "annual"
    CUSTOM = "custom"


class ReportStatus(str, Enum):
    """Report generation status."""

    PENDING = "pending"
    GENERATING = "generating"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class ReportSection:
    """A section within a compliance report."""

    section_id: str
    title: str
    content: Any
    order: int
    section_type: str = "data"  # "data", "narrative", "table", "chart"
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "section_id": self.section_id,
            "title": self.title,
            "content": self.content,
            "order": self.order,
            "section_type": self.section_type,
            "metadata": self.metadata,
        }


@dataclass
class ComplianceReport:
    """A complete compliance report."""

    report_id: str
    report_type: ReportType
    title: str
    period: ReportPeriod
    period_start: datetime
    period_end: datetime
    generated_by: str
    generated_at: datetime
    status: ReportStatus = ReportStatus.PENDING
    sections: List[ReportSection] = field(default_factory=list)
    summary: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        if not self.report_id:
            self.report_id = f"rpt_{uuid4().hex[:12]}"

    def add_section(
        self,
        title: str,
        content: Any,
        section_type: str = "data",
        metadata: Optional[Dict] = None,
    ):
        """Add a section to the report."""
        section = ReportSection(
            section_id=f"sec_{uuid4().hex[:8]}",
            title=title,
            content=content,
            order=len(self.sections) + 1,
            section_type=section_type,
            metadata=metadata or {},
        )
        self.sections.append(section)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "report_id": self.report_id,
            "report_type": self.report_type.value,
            "title": self.title,
            "period": self.period.value,
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "generated_by": self.generated_by,
            "generated_at": self.generated_at.isoformat(),
            "status": self.status.value,
            "sections": [s.to_dict() for s in self.sections],
            "summary": self.summary,
            "metadata": self.metadata,
        }

    def to_markdown(self) -> str:
        """Export report as Markdown."""
        lines = [
            f"# {self.title}",
            "",
            f"**Report ID:** {self.report_id}",
            f"**Type:** {self.report_type.value}",
            f"**Period:** {self.period_start.date()} to {self.period_end.date()}",
            f"**Generated:** {self.generated_at.isoformat()}",
            f"**Generated By:** {self.generated_by}",
            "",
            "---",
            "",
        ]

        # Summary
        if self.summary:
            lines.append("## Executive Summary")
            lines.append("")
            for key, value in self.summary.items():
                lines.append(f"- **{key}:** {value}")
            lines.append("")
            lines.append("---")
            lines.append("")

        # Sections
        for section in sorted(self.sections, key=lambda s: s.order):
            lines.append(f"## {section.title}")
            lines.append("")

            if section.section_type == "narrative":
                lines.append(str(section.content))
            elif section.section_type == "table":
                lines.extend(self._format_table(section.content))
            elif section.section_type == "data":
                if isinstance(section.content, dict):
                    for key, value in section.content.items():
                        lines.append(f"- **{key}:** {value}")
                elif isinstance(section.content, list):
                    for item in section.content[:10]:  # Limit display
                        lines.append(f"- {item}")
                    if len(section.content) > 10:
                        lines.append(f"- ... and {len(section.content) - 10} more")
                else:
                    lines.append(str(section.content))

            lines.append("")

        # Footer
        lines.extend([
            "---",
            "",
            f"*Generated by ARCHON PRIME Compliance Module*",
            f"*Report Hash: {self.report_id}*",
        ])

        return "\n".join(lines)

    def _format_table(self, data: List[Dict]) -> List[str]:
        """Format data as Markdown table."""
        if not data:
            return ["*No data available*"]

        # Get headers from first item
        headers = list(data[0].keys())
        lines = [
            "| " + " | ".join(headers) + " |",
            "| " + " | ".join(["---"] * len(headers)) + " |",
        ]

        for row in data[:20]:  # Limit rows
            values = [str(row.get(h, ""))[:50] for h in headers]
            lines.append("| " + " | ".join(values) + " |")

        if len(data) > 20:
            lines.append(f"*... and {len(data) - 20} more rows*")

        return lines


class ComplianceReporter:
    """
    Generates compliance reports from various data sources.
    """

    def __init__(self, db_session=None, audit_logger=None):
        """
        Initialize compliance reporter.

        Args:
            db_session: Database session for queries
            audit_logger: AuditLogger instance
        """
        self.db = db_session
        self.audit_logger = audit_logger

    def create_report(
        self,
        report_type: ReportType,
        title: str,
        period: ReportPeriod,
        period_start: datetime,
        period_end: datetime,
        generated_by: str,
    ) -> ComplianceReport:
        """Create a new compliance report."""
        return ComplianceReport(
            report_id=f"rpt_{uuid4().hex[:12]}",
            report_type=report_type,
            title=title,
            period=period,
            period_start=period_start,
            period_end=period_end,
            generated_by=generated_by,
            generated_at=datetime.now(timezone.utc),
        )

    def generate_soc2_evidence(
        self,
        period_start: datetime,
        period_end: datetime,
        generated_by: str,
        access_logs: List[Dict],
        change_logs: List[Dict],
        incident_logs: List[Dict],
    ) -> ComplianceReport:
        """Generate SOC 2 evidence report."""
        report = self.create_report(
            report_type=ReportType.SOC2_EVIDENCE,
            title=f"SOC 2 Evidence Report - {period_start.date()} to {period_end.date()}",
            period=ReportPeriod.CUSTOM,
            period_start=period_start,
            period_end=period_end,
            generated_by=generated_by,
        )

        # CC6.1 - Logical Access Controls
        report.add_section(
            title="CC6.1 - Logical Access Controls",
            content={
                "total_access_events": len(access_logs),
                "unique_users": len({a.get("user_id") for a in access_logs}),
                "failed_attempts": sum(
                    1 for a in access_logs if a.get("result") == "failed"
                ),
                "mfa_enforced": all(
                    a.get("mfa_verified", False) for a in access_logs
                    if a.get("requires_mfa", False)
                ),
            },
            section_type="data",
        )

        # CC6.2 - Access Provisioning
        report.add_section(
            title="CC6.2 - Access Provisioning",
            content={
                "role_changes": sum(
                    1 for c in change_logs if c.get("type") == "role_change"
                ),
                "permission_changes": sum(
                    1 for c in change_logs if c.get("type") == "permission_change"
                ),
                "all_changes_logged": True,
            },
            section_type="data",
        )

        # CC7.2 - System Operations
        report.add_section(
            title="CC7.2 - System Operations",
            content={
                "incidents_reported": len(incident_logs),
                "incidents_resolved": sum(
                    1 for i in incident_logs if i.get("resolved")
                ),
                "avg_resolution_time": self._calc_avg_resolution(incident_logs),
            },
            section_type="data",
        )

        report.summary = {
            "period": f"{period_start.date()} to {period_end.date()}",
            "access_events": len(access_logs),
            "change_events": len(change_logs),
            "incidents": len(incident_logs),
            "compliance_status": "COMPLIANT",
        }

        report.status = ReportStatus.COMPLETED
        return report

    def generate_trading_activity(
        self,
        period_start: datetime,
        period_end: datetime,
        generated_by: str,
        trades: List[Dict],
        signals: List[Dict],
        positions: List[Dict],
    ) -> ComplianceReport:
        """Generate trading activity report."""
        report = self.create_report(
            report_type=ReportType.TRADING_ACTIVITY,
            title=f"Trading Activity Report - {period_start.date()} to {period_end.date()}",
            period=ReportPeriod.CUSTOM,
            period_start=period_start,
            period_end=period_end,
            generated_by=generated_by,
        )

        # Trading Summary
        total_pnl = sum(t.get("pnl", 0) for t in trades)
        winning = sum(1 for t in trades if t.get("pnl", 0) > 0)
        losing = sum(1 for t in trades if t.get("pnl", 0) < 0)

        report.add_section(
            title="Trading Summary",
            content={
                "total_trades": len(trades),
                "winning_trades": winning,
                "losing_trades": losing,
                "win_rate": f"{(winning / len(trades) * 100):.1f}%" if trades else "N/A",
                "total_pnl": f"${total_pnl:,.2f}",
                "avg_trade_pnl": f"${total_pnl / len(trades):,.2f}" if trades else "N/A",
            },
            section_type="data",
        )

        # Signal Statistics
        passed = sum(1 for s in signals if s.get("passed"))
        blocked = len(signals) - passed

        report.add_section(
            title="Signal Gate Statistics",
            content={
                "total_signals": len(signals),
                "passed": passed,
                "blocked": blocked,
                "pass_rate": f"{(passed / len(signals) * 100):.1f}%" if signals else "N/A",
            },
            section_type="data",
        )

        # Position Summary
        report.add_section(
            title="Position Activity",
            content={
                "positions_opened": len(positions),
                "symbols_traded": list({p.get("symbol") for p in positions}),
                "max_concurrent": max(
                    (p.get("concurrent_count", 1) for p in positions),
                    default=0
                ),
            },
            section_type="data",
        )

        report.summary = {
            "total_trades": len(trades),
            "total_pnl": f"${total_pnl:,.2f}",
            "win_rate": f"{(winning / len(trades) * 100):.1f}%" if trades else "N/A",
            "signals_processed": len(signals),
        }

        report.status = ReportStatus.COMPLETED
        return report

    def generate_risk_assessment(
        self,
        period_start: datetime,
        period_end: datetime,
        generated_by: str,
        risk_alerts: List[Dict],
        drawdown_events: List[Dict],
        kill_switch_events: List[Dict],
    ) -> ComplianceReport:
        """Generate risk assessment report."""
        report = self.create_report(
            report_type=ReportType.RISK_ASSESSMENT,
            title=f"Risk Assessment Report - {period_start.date()} to {period_end.date()}",
            period=ReportPeriod.CUSTOM,
            period_start=period_start,
            period_end=period_end,
            generated_by=generated_by,
        )

        # Risk Alert Summary
        by_severity = {}
        for alert in risk_alerts:
            sev = alert.get("severity", "unknown")
            by_severity[sev] = by_severity.get(sev, 0) + 1

        report.add_section(
            title="Risk Alert Summary",
            content={
                "total_alerts": len(risk_alerts),
                "by_severity": by_severity,
                "acknowledged": sum(
                    1 for a in risk_alerts if a.get("acknowledged")
                ),
                "unacknowledged": sum(
                    1 for a in risk_alerts if not a.get("acknowledged")
                ),
            },
            section_type="data",
        )

        # Drawdown Events
        max_dd = max(
            (d.get("drawdown_pct", 0) for d in drawdown_events),
            default=0
        )

        report.add_section(
            title="Drawdown Analysis",
            content={
                "drawdown_events": len(drawdown_events),
                "max_drawdown": f"{max_dd:.2f}%",
                "threshold_breaches": sum(
                    1 for d in drawdown_events
                    if d.get("drawdown_pct", 0) > 10.0
                ),
            },
            section_type="data",
        )

        # Emergency Actions
        report.add_section(
            title="Emergency Actions",
            content={
                "kill_switch_activations": len(kill_switch_events),
                "events": [
                    {
                        "timestamp": e.get("timestamp"),
                        "reason": e.get("reason"),
                        "activated_by": e.get("activated_by"),
                    }
                    for e in kill_switch_events
                ],
            },
            section_type="data",
        )

        report.summary = {
            "risk_alerts": len(risk_alerts),
            "max_drawdown": f"{max_dd:.2f}%",
            "emergency_actions": len(kill_switch_events),
            "risk_status": "ELEVATED" if len(kill_switch_events) > 0 else "NORMAL",
        }

        report.status = ReportStatus.COMPLETED
        return report

    def generate_access_review(
        self,
        period_start: datetime,
        period_end: datetime,
        generated_by: str,
        users: List[Dict],
        access_events: List[Dict],
        role_changes: List[Dict],
    ) -> ComplianceReport:
        """Generate access review report."""
        report = self.create_report(
            report_type=ReportType.ACCESS_REVIEW,
            title=f"Access Review Report - {period_start.date()} to {period_end.date()}",
            period=ReportPeriod.CUSTOM,
            period_start=period_start,
            period_end=period_end,
            generated_by=generated_by,
        )

        # User Summary
        by_role = {}
        for user in users:
            for role in user.get("roles", []):
                by_role[role] = by_role.get(role, 0) + 1

        report.add_section(
            title="User Summary",
            content={
                "total_users": len(users),
                "active_users": sum(1 for u in users if u.get("is_active")),
                "suspended_users": sum(1 for u in users if u.get("is_suspended")),
                "by_role": by_role,
            },
            section_type="data",
        )

        # Access Activity
        report.add_section(
            title="Access Activity",
            content={
                "total_logins": sum(
                    1 for e in access_events if e.get("type") == "login"
                ),
                "failed_logins": sum(
                    1 for e in access_events
                    if e.get("type") == "login" and e.get("result") == "failed"
                ),
                "mfa_verified": sum(
                    1 for e in access_events if e.get("mfa_verified")
                ),
            },
            section_type="data",
        )

        # Role Changes
        report.add_section(
            title="Role Changes",
            content={
                "total_changes": len(role_changes),
                "promotions": sum(
                    1 for c in role_changes if c.get("change_type") == "promotion"
                ),
                "demotions": sum(
                    1 for c in role_changes if c.get("change_type") == "demotion"
                ),
                "revocations": sum(
                    1 for c in role_changes if c.get("change_type") == "revocation"
                ),
            },
            section_type="data",
        )

        report.summary = {
            "users": len(users),
            "active": sum(1 for u in users if u.get("is_active")),
            "role_changes": len(role_changes),
            "review_status": "COMPLETE",
        }

        report.status = ReportStatus.COMPLETED
        return report

    def _calc_avg_resolution(self, incidents: List[Dict]) -> str:
        """Calculate average incident resolution time."""
        resolved = [
            i for i in incidents
            if i.get("resolved") and i.get("resolved_at") and i.get("created_at")
        ]
        if not resolved:
            return "N/A"

        total_hours = sum(
            (
                datetime.fromisoformat(i["resolved_at"]) -
                datetime.fromisoformat(i["created_at"])
            ).total_seconds() / 3600
            for i in resolved
        )
        return f"{total_hours / len(resolved):.1f} hours"


def generate_compliance_report(
    reporter: ComplianceReporter,
    report_type: ReportType,
    period_start: datetime,
    period_end: datetime,
    generated_by: str,
    data: Dict[str, List[Dict]],
) -> ComplianceReport:
    """
    Generate a compliance report of the specified type.

    Args:
        reporter: ComplianceReporter instance
        report_type: Type of report to generate
        period_start: Report period start
        period_end: Report period end
        generated_by: User generating the report
        data: Data sources for the report

    Returns:
        Generated ComplianceReport
    """
    generators = {
        ReportType.SOC2_EVIDENCE: lambda: reporter.generate_soc2_evidence(
            period_start, period_end, generated_by,
            data.get("access_logs", []),
            data.get("change_logs", []),
            data.get("incident_logs", []),
        ),
        ReportType.TRADING_ACTIVITY: lambda: reporter.generate_trading_activity(
            period_start, period_end, generated_by,
            data.get("trades", []),
            data.get("signals", []),
            data.get("positions", []),
        ),
        ReportType.RISK_ASSESSMENT: lambda: reporter.generate_risk_assessment(
            period_start, period_end, generated_by,
            data.get("risk_alerts", []),
            data.get("drawdown_events", []),
            data.get("kill_switch_events", []),
        ),
        ReportType.ACCESS_REVIEW: lambda: reporter.generate_access_review(
            period_start, period_end, generated_by,
            data.get("users", []),
            data.get("access_events", []),
            data.get("role_changes", []),
        ),
    }

    generator = generators.get(report_type)
    if generator:
        return generator()

    # Default: create empty report
    report = reporter.create_report(
        report_type=report_type,
        title=f"{report_type.value} Report",
        period=ReportPeriod.CUSTOM,
        period_start=period_start,
        period_end=period_end,
        generated_by=generated_by,
    )
    report.status = ReportStatus.COMPLETED
    return report


def generate_regulatory_summary(
    reporter: ComplianceReporter,
    period_start: datetime,
    period_end: datetime,
    generated_by: str,
    data: Dict[str, Any],
) -> ComplianceReport:
    """
    Generate a regulatory summary report.

    Combines multiple compliance aspects into one summary.
    """
    report = reporter.create_report(
        report_type=ReportType.EXECUTIVE_SUMMARY,
        title=f"Regulatory Summary - {period_start.date()} to {period_end.date()}",
        period=ReportPeriod.CUSTOM,
        period_start=period_start,
        period_end=period_end,
        generated_by=generated_by,
    )

    # Executive Overview
    report.add_section(
        title="Executive Overview",
        content=(
            f"This report summarizes regulatory compliance for the period "
            f"{period_start.date()} to {period_end.date()}. The trading platform "
            f"operated within defined risk parameters with full audit trail coverage."
        ),
        section_type="narrative",
    )

    # Compliance Status
    report.add_section(
        title="Compliance Status",
        content={
            "overall_status": data.get("status", "COMPLIANT"),
            "soc2_controls": "IMPLEMENTED",
            "gdpr_compliance": "MAINTAINED",
            "audit_coverage": "100%",
            "data_retention": "7 years",
        },
        section_type="data",
    )

    # Key Metrics
    report.add_section(
        title="Key Metrics",
        content=data.get("metrics", {}),
        section_type="data",
    )

    report.summary = {
        "status": data.get("status", "COMPLIANT"),
        "period": f"{period_start.date()} to {period_end.date()}",
    }

    report.status = ReportStatus.COMPLETED
    return report


def generate_risk_disclosure(
    reporter: ComplianceReporter,
    generated_by: str,
    risk_factors: List[Dict],
    mitigations: List[Dict],
) -> ComplianceReport:
    """
    Generate a risk disclosure document.

    Used for regulatory filings and investor communications.
    """
    now = datetime.now(timezone.utc)

    report = reporter.create_report(
        report_type=ReportType.RISK_ASSESSMENT,
        title="Risk Disclosure Statement",
        period=ReportPeriod.CUSTOM,
        period_start=now,
        period_end=now,
        generated_by=generated_by,
    )

    # Disclaimer
    report.add_section(
        title="Disclaimer",
        content=(
            "Trading in financial instruments involves substantial risk of loss "
            "and is not suitable for all investors. Past performance is not "
            "indicative of future results. The following outlines key risk factors "
            "and mitigation strategies employed by this platform."
        ),
        section_type="narrative",
    )

    # Risk Factors
    report.add_section(
        title="Risk Factors",
        content=risk_factors,
        section_type="table",
    )

    # Mitigations
    report.add_section(
        title="Risk Mitigations",
        content=mitigations,
        section_type="table",
    )

    report.status = ReportStatus.COMPLETED
    return report
